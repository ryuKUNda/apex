(() => {
  "use strict";
  var e = {
      780: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Core = void 0;
        const s = i(610),
          r = i(324),
          n = Array(60).fill(0).map(((e, t) => t));
        class a {
          constructor(e, t) {
            this.process = e, this.region = t
          }
          static async createAsync(e) {
            const t = (await e.processesAsync()).find((e => e.command.toLowerCase().endsWith("r5apex.exe")));
            if (!t) throw new Error("Invalid process!");
            const i = await t.regionsAsync(),
              s = i.find((e => e.pathname.toLowerCase().endsWith("r5apex.exe"))) ? ? i.find((e => 1 == e.perms && e.pathname.startsWith("/memfd"))) ? ? i.find((e => e.start === BigInt(5368709120)));
            if (!s) throw new Error("Invalid region!");
            return new a(t, s)
          }
          async levelNameAsync() {
            const e = new s.CStringPointer(this.region.start + r.coreOffsets.levelName, 32);
            return await this.process.batch(e).readAsync(), e.value
          }
          async playersAsync() {
            const e = new s.UInt64Pointer(this.region.start + r.coreOffsets.localPlayer),
              t = n.map((e => new s.UInt64Pointer(this.region.start + r.coreOffsets.clEntityList + BigInt(e << 5))));
            await this.process.batch(e, t).readAsync();
            const i = e.value,
              a = t.map((e => e.value)).filter(Boolean).map((e => new s.Player(e, i === e)));
            return await this.process.batch(function (e) {
              return e.flatMap((e => Object.values(e).filter((e => e instanceof s.Pointer))))
            }(a)).readAsync(), a.filter((e => e.isValid))
          }
        }
        t.Core = a
      },
      322: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Entity = void 0;
        const s = i(610),
          r = i(661);
        t.Entity = class {
          constructor(e, t = new s.VectorPointer(e + r.entityOffsets.localOrigin), i = new s.UInt8Pointer(e + r.entityOffsets.iTeamNum), n = new s.UInt64Pointer(e + r.entityOffsets.iName), a = new s.UInt8Pointer(e + r.entityOffsets.glowEnable), o = new s.UInt8Pointer(e + r.entityOffsets.glowThroughWall)) {
            this.localOrigin = t, this.teamNum = i, this.name = n, this.glowEnable = a, this.glowThroughWalls = o
          }
        }
      },
      194: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Player = void 0;
        const s = i(610),
          r = i(169);
        class n extends s.Entity {
          constructor(e, t, i = new s.UInt8Pointer(e + r.playerOffsets.lifeState), n = new s.VectorPointer(e + r.playerOffsets.viewAngles), a = new s.UInt8Pointer(e + r.playerOffsets.bleedoutState)) {
            super(e), this.isLocal = t, this.lifeState = i, this.viewAngles = n, this.bleedoutState = a
          }
          get isValid() {
            return this.name.value && !this.lifeState.value && !s.shallowEquals(this.localOrigin.value, new s.Vector(0, 0, 0))
          }
          createColor(e, t) {
            return this.isLocal ? "#0000FF" : this.isSameTeam(e, t) ? this.bleedoutState.value ? "#FFFF00" : "#00FF00" : this.bleedoutState.value ? "#FFA500" : "#FF0000"
          }
          isSameTeam(e, t) {
            return "control" === t ? this.teamNum.value % 2 == e.teamNum.value % 2 : this.teamNum.value === e.teamNum.value
          }
          toString() {
            return s.serialize(this)
          }
        }
        t.Player = n
      },
      324: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.coreOffsets = void 0, t.coreOffsets = {
          levelName: BigInt("0x1380370"),
          clEntityList: BigInt("0x1a203b8"),
          localPlayer: BigInt("0x1dd15e8")
        }
      },
      661: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.entityOffsets = void 0, t.entityOffsets = {
          localOrigin: BigInt("0x158"),
          iTeamNum: BigInt("0x448"),
          iName: BigInt("0x589"),
          glowEnable: BigInt("0x3c8"),
          glowThroughWall: BigInt("0x3d0")
        }
      },
      169: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.playerOffsets = void 0, t.playerOffsets = {
          lifeState: BigInt("0x798"),
          viewAngles: BigInt("0x2580"),
          bleedoutState: BigInt("0x2720")
        }
      },
      787: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Batch = void 0;
        t.Batch = class {
          constructor(e, t) {
            this.pid = e, this.pointers = t
          }
          async readAsync() {
            if (!this.pointers.length) return;
            const e = this.pointers.map((e => `${e.address.toString(16)}:${e.bufferSize.toString(16)}`)).join(","),
              t = await fetch(`/api/proc/${this.pid}/mem/${e}`),
              i = await t.arrayBuffer().then((e => new DataView(e)));
            for (let e = 0; e < i.byteLength; e += 2) {
              const t = i.getUint16(e, !0),
                s = this.pointers[t].bufferSize;
              this.pointers[t].buffer = new DataView(i.buffer, e + 2, s), e += s
            }
          }
          async writeAsync() {
            if (!this.pointers.length) return;
            const e = await new Blob(this.pointers.map((e => e.buffer))).arrayBuffer(),
              t = this.pointers.map((e => `${e.address.toString(16)}:${e.bufferSize.toString(16)}`)).join(",");
            await fetch(`/api/proc/${this.pid}/mem/${t}`, {
              body: e,
              method: "PUT"
            })
          }
        }
      },
      700: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Pointer = void 0;
        t.Pointer = class {
          constructor(e, t) {
            this.address = e, this.bufferSize = t
          }
          get buffer() {
            if (this.cache) return this.cache;
            throw new Error(`Unresolved pointer ${this.address.toString(16)}`)
          }
          set buffer(e) {
            this.cache = e
          }
        }
      },
      543: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Process = void 0;
        const s = i(610);
        t.Process = class {
          constructor(e, t = e.args, i = e.command, s = e.pid) {
            this.args = t, this.command = i, this.pid = s
          }
          batch(...e) {
            return new s.Batch(this.pid, e.flatMap((e => e)))
          }
          async regionsAsync() {
            const e = await fetch(`/api/proc/${this.pid}/maps`);
            return (await e.json()).map((e => new s.Region(e)))
          }
        }
      },
      927: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Region = void 0;

        function i(e) {
          return /^0x/i.test(e) ? BigInt(e) : BigInt(`0x${e}`)
        }
        t.Region = class {
          constructor(e, t = i(e.start), s = i(e.end), r = e.perms, n = i(e.offset), a = e.devMajor, o = e.devMinor, c = i(e.inode), h = e.pathname) {
            this.start = t, this.end = s, this.perms = r, this.offset = n, this.devMajor = a, this.devMinor = o, this.inode = c, this.pathname = h
          }
        }
      },
      798: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Server = void 0;
        const s = i(610);
        t.Server = class {
          async processesAsync() {
            const e = await fetch("/api/proc");
            return (await e.json()).map((e => new s.Process(e)))
          }
          async versionAsync() {
            const e = await fetch("/api/version");
            return await e.json().catch((() => 0))
          }
        }
      },
      951: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Map = void 0;
        t.Map = class {
          constructor(e) {
            this.canvas = e, this.image = new Image, this.ratioX = 0, this.ratioY = 0, this.scaleR = 0, this.scaleX = 0, this.scaleY = 0, this.shiftX = 0, this.shiftY = 0, this.context = e.getContext("2d")
          }
          refresh(e) {
            this.fetch(e), this.update(), this.renderBackground()
          }
          renderAll(e, t, i) {
            for (const s of t) this.renderOne(s.localOrigin.value, s.createColor(e, i))
          }
          renderOne(e, t) {
            if (!this.map) return;
            const i = this.shiftX + 1 / this.image.width * this.scaleX * (e.x - this.map.x) / this.ratioX,
              s = this.shiftY + 1 / this.image.height * this.scaleY * (e.y - this.map.y) / -this.ratioY;
            this.context.beginPath(), this.context.arc(i, s, 8 * this.scaleR, 0, 2 * Math.PI), this.context.fillStyle = t, this.context.fill()
          }
          fetch(e) {
            this.map = function (e) {
              switch (e) {
              case "mp_rr_canyonlands_mu3":
                return {
                  x: -37541,
                  y: 43886
                };
              case "mp_rr_desertlands_mu3":
                return {
                  x: -45056,
                  y: 45055
                };
              case "mp_rr_olympus_mu2":
                return {
                  x: -52024,
                  y: 48025
                };
              case "mp_rr_tropic_island_mu1":
                return {
                  x: -50606,
                  y: 52139
                };
              default:
                return
              }
            }(e), this.image.src = this.map ? `images/maps/${e}.webp` : "images/maps.webp"
          }
          renderBackground() {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.drawImage(this.image, 0, 0, this.image.width, this.image.height, this.shiftX, this.shiftY, this.scaleX, this.scaleY)
          }
          update() {
            this.map && (this.ratioX = (this.map.y - this.map.x) / this.image.width, this.ratioY = (this.map.y - this.map.x) / this.image.height, this.scaleR = Math.min(this.canvas.width / this.image.width, this.canvas.height / this.image.height), this.scaleX = this.image.width * this.scaleR, this.scaleY = this.image.height * this.scaleR, this.shiftX = (this.canvas.width - this.scaleX) / 2, this.shiftY = (this.canvas.height - this.scaleY) / 2)
          }
        }
      },
      767: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Radar = void 0;
        t.Radar = class {
          constructor(e, t = 200, i = 8) {
            this.canvas = e, this.maximumDistance = t, this.numberOfRings = i, this.centerX = 0, this.centerY = 0, this.outerRadius = 0, this.context = e.getContext("2d")
          }
          refresh() {
            this.update(), this.renderBackground(), this.renderLines(), this.renderRings()
          }
          renderAll(e, t, i) {
            for (const s of t) s.isLocal || this.renderOne(e, s.localOrigin.value, s.createColor(e, i))
          }
          renderOne(e, t, i) {
            const s = .0254 * (e.localOrigin.value.x - t.x),
              r = .0254 * (e.localOrigin.value.y - t.y),
              n = Math.sqrt(Math.pow(s, 2) + Math.pow(r, 2));
            if (n < this.maximumDistance) {
              const t = this.outerRadius / this.maximumDistance,
                a = Math.sign(r) * Math.acos(s / n) - e.viewAngles.value.y * Math.PI / 180,
                o = this.centerX + Math.sin(a) * n * t,
                c = this.centerY + Math.cos(a) * n * t;
              this.context.beginPath(), this.context.arc(o, c, this.outerRadius / 40, 0, 2 * Math.PI), this.context.fillStyle = i, this.context.fill()
            }
          }
          renderBackground() {
            this.context.beginPath(), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.arc(this.centerX, this.centerY, this.outerRadius, 0, 2 * Math.PI), this.context.fillStyle = "#000", this.context.fill()
          }
          renderLines() {
            this.context.strokeStyle = "#FFF";
            for (let e = 0; e < 8; e++) {
              const t = this.centerX + this.outerRadius * Math.cos(e * Math.PI * .25),
                i = this.centerY + this.outerRadius * Math.sin(e * Math.PI * .25);
              this.context.beginPath(), this.context.moveTo(this.centerX, this.centerY), this.context.lineTo(t, i), this.context.stroke()
            }
          }
          renderRings() {
            this.context.strokeStyle = "#FFF";
            for (let e = 1; e <= this.numberOfRings; e++) this.context.beginPath(), this.context.arc(this.centerX, this.centerY, this.outerRadius * e / this.numberOfRings, 0, 2 * Math.PI), this.context.stroke()
          }
          update() {
            this.centerX = this.canvas.width / 2, this.centerY = this.canvas.height / 2, this.outerRadius = (this.canvas.width > this.canvas.height ? this.canvas.height : this.canvas.width) / 2
          }
        }
      },
      123: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Sense = void 0;
        t.Sense = class {
          constructor(e, t = 200) {
            this.core = e, this.maximumDistance = t
          }
          async updateAsync(e, t, i) {
            const s = [];
            this.collectChanges(e, t, s, i), await this.core.process.batch(s).writeAsync()
          }
          collectChanges(e, t, i, s) {
            for (const r of t) {
              if (r.isSameTeam(e, s) || [0, 255].includes(r.glowEnable.value)) continue;
              const t = .0254 * (e.localOrigin.value.x - r.localOrigin.value.x),
                n = .0254 * (e.localOrigin.value.y - r.localOrigin.value.y);
              if (Math.sqrt(Math.pow(t, 2) + Math.pow(n, 2)) < this.maximumDistance) {
                const e = 7,
                  t = 2;
                r.glowEnable.value === e && r.glowThroughWalls.value === t || (r.glowEnable.value = e, r.glowThroughWalls.value = t, i.push(r.glowEnable, r.glowThroughWalls))
              }
            }
          }
        }
      },
      893: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.shallowEquals = t.serialize = void 0, t.serialize = function (e) {
          return `(${Object.entries(e).sort((([e],[t])=>e.localeCompare(t))).map((([e,t])=>`${e}=${t}`)).join(",")})`
        }, t.shallowEquals = function (e, t) {
          return Object.entries(e).map((([e, i]) => [i, t[e]])).every((([e, t]) => e === t))
        }
      },
      610: function (e, t, i) {
        var s = this && this.__createBinding || (Object.create ? function (e, t, i, s) {
            void 0 === s && (s = i);
            var r = Object.getOwnPropertyDescriptor(t, i);
            r && !("get" in r ? !t.__esModule : r.writable || r.configurable) || (r = {
              enumerable: !0,
              get: function () {
                return t[i]
              }
            }), Object.defineProperty(e, s, r)
          } : function (e, t, i, s) {
            void 0 === s && (s = i), e[s] = t[i]
          }),
          r = this && this.__exportStar || function (e, t) {
            for (var i in e) "default" === i || Object.prototype.hasOwnProperty.call(t, i) || s(t, e, i)
          };
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), r(i(893), t), r(i(787), t), r(i(700), t), r(i(543), t), r(i(927), t), r(i(798), t), r(i(780), t), r(i(322), t), r(i(194), t), r(i(951), t), r(i(767), t), r(i(123), t), r(i(37), t), r(i(630), t), r(i(145), t), r(i(113), t), r(i(811), t), r(i(558), t)
      },
      630: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.UInt64Pointer = void 0;
        const s = i(610);
        class r extends s.Pointer {
          constructor(e) {
            super(e, 8)
          }
          get value() {
            return this.buffer.getBigUint64(0, !0)
          }
          set value(e) {
            this.buffer.setBigUint64(0, e, !0)
          }
          toString() {
            return this.value.toString()
          }
        }
        t.UInt64Pointer = r
      },
      37: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.UInt8Pointer = void 0;
        const s = i(610);
        class r extends s.Pointer {
          constructor(e) {
            super(e, 1)
          }
          get value() {
            return this.buffer.getUint8(0)
          }
          set value(e) {
            this.buffer.setUint8(0, e)
          }
          toString() {
            return this.value.toString()
          }
        }
        t.UInt8Pointer = r
      },
      145: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.CString = void 0;
        t.CString = class extends String {
          static from(e) {
            let t = "";
            return function (e, t) {
              for (let i = 0; i < e.byteLength; i++) {
                const s = e.getUint8(i);
                if (0 === s) break;
                t(String.fromCharCode(s))
              }
            }(e, (e => t += e)), t
          }
        }
      },
      113: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.CStringPointer = void 0;
        const s = i(610);
        class r extends s.Pointer {
          get value() {
            return s.CString.from(this.buffer)
          }
          toString() {
            return this.value.toString()
          }
        }
        t.CStringPointer = r
      },
      811: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.Vector = void 0;
        const s = i(610);
        class r {
          constructor(e, t, i) {
            this.x = e, this.y = t, this.z = i
          }
          static from(e) {
            const t = e.getFloat32(0, !0),
              i = e.getFloat32(4, !0),
              s = e.getFloat32(8, !0);
            return new r(t, i, s)
          }
          toBuffer() {
            const e = new DataView(new ArrayBuffer(12));
            return e.setFloat32(0, this.x, !0), e.setFloat32(4, this.y, !0), e.setFloat32(8, this.z, !0), e
          }
          toString() {
            return s.serialize(this)
          }
        }
        t.Vector = r
      },
      558: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.VectorPointer = void 0;
        const s = i(610);
        class r extends s.Pointer {
          constructor(e) {
            super(e, 12)
          }
          get value() {
            return s.Vector.from(this.buffer)
          }
          set value(e) {
            this.buffer = e.toBuffer()
          }
          toString() {
            return this.value.toString()
          }
        }
        t.VectorPointer = r
      },
      842: (e, t, i) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.ui = void 0;
        const s = i(610),
          r = i(732),
          n = document.querySelector(".container"),
          a = document.querySelector(".content"),
          o = new s.Server;
        async function c(e) {
          const t = await s.Core.createAsync(o).catch((() => {}));
          return !!t && (n.style.display = "none", await e(t).catch(console.error.bind(console)), n.style.display = "inherit", !0)
        }
        t.ui = async function (e) {
          for (;;) switch (await new Promise((e => setTimeout(e, 1e3))), await o.versionAsync()) {
          case 0:
            a.innerHTML = r.language.errorDriver;
            break;
          case 3:
            a.innerHTML = await c(e) ? r.language.error : r.language.errorProcess;
            break;
          default:
            a.innerHTML = r.language.errorVersion
          }
        }
      },
      732: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.language = void 0, t.language = {
          error: "An error occurred. Check your console.",
          errorDriver: 'Load this connector in your <a href="https://github.com/XRadius/http-driver" target="_blank">http-driver</a>.',
          errorProcess: "Game not found. Did you run it?",
          errorVersion: 'Your <a href="https://github.com/XRadius/http-driver" target="_blank">http-driver</a> is outdated.'
        }
      }
    },
    t = {};

  function i(s) {
    var r = t[s];
    if (void 0 !== r) return r.exports;
    var n = t[s] = {
      exports: {}
    };
    return e[s].call(n.exports, n, n.exports, i), n.exports
  }(() => {
    const e = i(610),
      t = i(842),
      s = document.querySelector(".canvas"),
      r = 1e3 / 30,
      n = new e.Radar(s);

    function a(t, i, s) {
      switch (t) {
      case "mp_rr_canyonlands_staging":
        if (n.refresh(), !i) break;
        n.renderOne(i, new e.Vector(31482.994140625, -6708.69677734375, 0), "#FFF");
        break;
      default:
        if (n.refresh(), !i) break;
        n.renderAll(i, s)
      }
    }
    async function o(e, t, i) {
      e && location.hash.includes("enable-sense") && await i.updateAsync(e, t)
    }
    s.addEventListener("dblclick", (() => {
      (document.fullscreenElement ? document.exitFullscreen() : document.body.requestFullscreen()).catch()
    })), (0, t.ui)((t => async function (e, t) {
      for (;;) {
        const i = Date.now(),
          [n, c] = await Promise.all([e.levelNameAsync(), e.playersAsync()]),
          h = c.find((e => e.isLocal));
        s.height = window.innerHeight, s.width = window.innerWidth, await Promise.all([a(n, h, c), o(h, c, t), new Promise((e => setTimeout(e, r - (Date.now() - i))))])
      }
    }(t, new e.Sense(t)).finally((() => {
      s.height = 0, s.width = 0
    }))))
  })()
})();
